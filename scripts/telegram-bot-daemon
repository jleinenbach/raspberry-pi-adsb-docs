#!/bin/bash
set -o pipefail
#===============================================================================
# Telegram Bot Daemon fÃ¼r ADS-B Feeder
# Befehle: /status, /stats, /log, /wartung, /do
#===============================================================================

# Sichere Config-Ladung (ohne source)
TELEGRAM_BOT_TOKEN=$(grep "^TELEGRAM_BOT_TOKEN=" /etc/telegram-notify.conf 2>/dev/null | cut -d= -f2- | tr -d '"')
TELEGRAM_CHAT_ID=$(grep "^TELEGRAM_CHAT_ID=" /etc/telegram-notify.conf 2>/dev/null | cut -d= -f2- | tr -d '"')

LAST_UPDATE_FILE="/var/run/telegram-bot-last-update"
ANSWER_FILE="/var/run/telegram-bot-answer"
QUESTION_FILE="/var/run/telegram-bot-question"
SESSION_DIR="/var/lib/claude-pending"
SESSION_FILE="$SESSION_DIR/session.json"
LOG_FILE="/var/log/telegram-bot.log"
DO_LOCK="/var/run/telegram-do.lock"
BOT_PID_FILE="/var/run/telegram-bot.pid"
COMMAND_LOCK="/var/run/telegram-command.lock"

# PID-Lock fÃ¼r Bot-Instanz (globaler FD)
acquire_bot_lock() {
    if ! flock -n 200; then
        echo "Bot lÃ¤uft bereits (Lock aktiv)" >&2
        exit 1
    fi
    echo $$ > "$BOT_PID_FILE"
}

release_bot_lock() {
    rm -f "$BOT_PID_FILE"
}
# Cleanup bei Exit
trap release_bot_lock EXIT INT TERM

MAX_MSG_LEN=1000
MAINTENANCE_LOCK="/var/run/claude-respond.lock"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

#-------------------------------------------------------------------------------
# Wartungs-Status prÃ¼fen
#-------------------------------------------------------------------------------
is_maintenance_running() {
    if [ -f "$MAINTENANCE_LOCK" ]; then
        local pid=$(cat "$MAINTENANCE_LOCK" 2>/dev/null)
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

get_maintenance_duration() {
    if [ -f "$MAINTENANCE_LOCK" ]; then
        local start=$(stat -c %Y "$MAINTENANCE_LOCK" 2>/dev/null)
        local now=$(date +%s)
        local dur=$((now - start))
        echo "$((dur / 60))min $((dur % 60))s"
    fi
}

#-------------------------------------------------------------------------------
# Telegram Nachricht senden (mit automatischer Aufteilung bei >4000 Zeichen)
#-------------------------------------------------------------------------------
MAX_TELEGRAM_LEN=4000

send_message_raw() {
    curl -s --max-time 10 -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
        -d chat_id="${TELEGRAM_CHAT_ID}" \
        -d text="$1" \
        -d parse_mode="Markdown" > /dev/null 2>&1
}

send_message() {
    local msg="$1"
    local len=${#msg}

    # Kurze Nachricht: direkt senden
    if [ $len -le $MAX_TELEGRAM_LEN ]; then
        send_message_raw "$msg"
        return
    fi

    # Lange Nachricht: aufteilen
    local parts=()
    local remaining="$msg"

    while [ ${#remaining} -gt $MAX_TELEGRAM_LEN ]; do
        local chunk="${remaining:0:$MAX_TELEGRAM_LEN}"
        local cut_pos=$MAX_TELEGRAM_LEN

        # Versuche an Doppel-Newline (Absatz) zu trennen
        local last_para=$(echo "$chunk" | grep -bo $'\n\n' 2>/dev/null | tail -1 | cut -d: -f1)
        if [ -n "$last_para" ] && [ "$last_para" -gt 2000 ]; then
            cut_pos=$((last_para + 2))
        else
            # Versuche an einfachem Newline zu trennen
            local last_nl=$(echo "$chunk" | grep -bo $'\n' 2>/dev/null | tail -1 | cut -d: -f1)
            if [ -n "$last_nl" ] && [ "$last_nl" -gt 2000 ]; then
                cut_pos=$((last_nl + 1))
            fi
        fi

        parts+=("${remaining:0:$cut_pos}")
        remaining="${remaining:$cut_pos}"
    done

    # Rest hinzufuegen
    [ -n "$remaining" ] && parts+=("$remaining")

    # Teile senden mit Nummerierung
    local total=${#parts[@]}
    local i=1
    for part in "${parts[@]}"; do
        if [ $total -gt 1 ]; then
            send_message_raw "($i/$total)
$part"
        else
            send_message_raw "$part"
        fi
        ((i++))
        # Kurze Pause fuer korrekte Reihenfolge
        [ $i -le $total ] && sleep 0.3
    done
}

sanitize_input() {
    local input="$1"
    input="${input:0:$MAX_MSG_LEN}"
    input=$(echo "$input" | tr -d '\000-\011\013-\037')
    echo "$input"
}

#-------------------------------------------------------------------------------
# Session-Status prÃ¼fen
#-------------------------------------------------------------------------------
has_open_session() {
    if [ -f "$SESSION_FILE" ]; then
        local expires=$(jq -r '.expires' "$SESSION_FILE" 2>/dev/null)
        local expires_ts=$(date -d "$expires" +%s 2>/dev/null || echo 0)
        local now_ts=$(date +%s)
        if [ "$now_ts" -lt "$expires_ts" ]; then
            return 0
        else
            local sid=$(jq -r '.id' "$SESSION_FILE")
            mv "$SESSION_FILE" "$SESSION_DIR/history/${sid}-expired.json" 2>/dev/null
            return 1
        fi
    fi
    return 1
}

get_session_remaining() {
    local expires=$(jq -r '.expires' "$SESSION_FILE" 2>/dev/null)
    local expires_ts=$(date -d "$expires" +%s 2>/dev/null || echo 0)
    local now_ts=$(date +%s)
    local remaining=$((expires_ts - now_ts))
    if [ "$remaining" -gt 3600 ]; then
        echo "$((remaining / 3600))h"
    else
        echo "$((remaining / 60))min"
    fi
}

handle_abbrechen() {
    if has_open_session; then
        local sid=$(jq -r '.id' "$SESSION_FILE")
        jq '.state = "cancelled"' "$SESSION_FILE" > "$SESSION_FILE.tmp" && chmod 600 "$SESSION_FILE.tmp" && mv "$SESSION_FILE.tmp" "$SESSION_FILE"
        mv "$SESSION_FILE" "$SESSION_DIR/history/${sid}-cancelled.json" 2>/dev/null
        rm -f "$QUESTION_FILE" "$ANSWER_FILE"
        send_message "âŒ Session abgebrochen."
        log "Session $sid abgebrochen"
    else
        send_message "ðŸ’¬ Keine offene Session."
    fi
}

#-------------------------------------------------------------------------------
# /do - Direkte Anweisung an Claude (schneller als /wartung)
#-------------------------------------------------------------------------------
handle_do() {
    local anweisung="$1"
    
    if [ -z "$anweisung" ]; then
        send_message "âš¡ Bitte Anweisung angeben:
/do Starte piaware neu
/do PrÃ¼fe AppArmor-Status
/do Zeige SSH-Konfiguration"
        return
    fi
    
    
    # Schnelle Blacklist-PrÃ¼fung (ohne Claude)
    local BLACKLIST="rm -rf /|mkfs|dd if=|format|fdisk|:(){:|chmod -R 777 /|> /dev/sd"
    for pattern in $BLACKLIST; do
        if echo "$anweisung" | grep -qi "$pattern"; then
            send_message "ðŸ›¡ï¸ *Abgelehnt:* GefÃ¤hrlicher Befehl erkannt."
            log "/do BLOCKED: $anweisung"
            return
        fi
    done
    
    # In Queue einfÃ¼gen
    local QUEUE_FILE="/var/lib/claude-pending/do-queue.json"
    local QUEUE_ID=$(date +%s%N | cut -c1-13)
    local TIMESTAMP=$(date -Iseconds)
    
    # Queue initialisieren falls nicht vorhanden
    [ ! -f "$QUEUE_FILE" ] && echo "[]" > "$QUEUE_FILE"
    
    # Eintrag hinzufÃ¼gen
    local NEW_ENTRY=$(jq -n --arg cmd "$anweisung" --arg ts "$TIMESTAMP" --arg id "$QUEUE_ID" \
        '{command: $cmd, timestamp: $ts, id: $id}')
    jq --argjson entry "$NEW_ENTRY" '. + [$entry]' "$QUEUE_FILE" > "$QUEUE_FILE.tmp" \
        && mv "$QUEUE_FILE.tmp" "$QUEUE_FILE"
    
    local QUEUE_LEN=$(jq length "$QUEUE_FILE")
    
    send_message "ðŸ“¥ *In Queue (#$QUEUE_ID)*
Position: $QUEUE_LEN
Anweisung: _${anweisung}_

â³ Wird verarbeitet sobald Claude frei ist (max 2 Min)."
    
    log "/do QUEUED #$QUEUE_ID: $anweisung"
    
    # Sofort Worker triggern falls Claude frei
    if ! pgrep -f "claude -p" > /dev/null 2>&1; then
        systemctl start do-queue-worker.service &
    fi
}

#-------------------------------------------------------------------------------
# Firmware-Status prÃ¼fen
#-------------------------------------------------------------------------------
get_firmware_status() {
    local eeprom_output=$(sudo rpi-eeprom-update 2>/dev/null)
    local bootloader_status=$(echo "$eeprom_output" | grep -E "^BOOTLOADER:" | awk '{print $2,$3,$4}')
    local vl805_status=$(echo "$eeprom_output" | grep -E "^\s*VL805:" | awk '{print $2,$3,$4}')

    fw_icon="ðŸŸ¢"
    if echo "$bootloader_status" | grep -qi "update available"; then
        fw_icon="ðŸŸ¡"
    fi
    if echo "$vl805_status" | grep -qi "update available"; then
        fw_icon="ðŸŸ¡"
    fi

    if [ "$fw_icon" = "ðŸŸ¢" ]; then
        fw_status="Aktuell"
    else
        fw_status="Update verfÃ¼gbar"
    fi
}

#-------------------------------------------------------------------------------
# /status - Kompakter Health-Check mit Ampeln
#-------------------------------------------------------------------------------
get_status() {
    local uptime_str=$(uptime -p | sed 's/up //' | sed 's/ days\?/d/;s/ hours\?/h/;s/ minutes\?/m/' | sed 's/, //g')
    local ram_pct=$(free | awk '/Mem:/ {printf "%.0f", $3/$2*100}')
    local ram_icon="ðŸŸ¢"
    [ "$ram_pct" -ge 50 ] && ram_icon="ðŸŸ¡"
    [ "$ram_pct" -ge 70 ] && ram_icon="ðŸŸ "
    [ "$ram_pct" -ge 85 ] && ram_icon="ðŸ”´"

    local cpu_load=$(cat /proc/loadavg | awk '{print $1}')
    local cpu_pct=$(awk "BEGIN {printf \"%.0f\", $cpu_load * 25}")
    local cpu_icon="ðŸŸ¢"
    [ "$cpu_pct" -ge 50 ] && cpu_icon="ðŸŸ¡"
    [ "$cpu_pct" -ge 70 ] && cpu_icon="ðŸŸ "
    [ "$cpu_pct" -ge 85 ] && cpu_icon="ðŸ”´"

    local rtl=$(lsusb | grep -qi rtl && echo "OK" || echo "FEHLT")
    local temp=$(vcgencmd measure_temp 2>/dev/null | grep -oP "[0-9.]+" || echo "0")

    # Spannungsu00fcberwachung
    local throttled=$(vcgencmd get_throttled 2>/dev/null | cut -d= -f2)
    local throttled="${throttled:-0x0}"
    local throttled_dec=$((throttled))
    local volt_bit0=$((throttled_dec & 0x1))
    local volt_bit16=$((throttled_dec & 0x10000))
    local volt_icon="ðŸŸ¢"
    local volt_status="OK"
    if [ "$throttled" = "0x0" ]; then
        volt_icon="ðŸŸ¢"
        volt_status="Stabil"
    elif [ "$volt_bit0" -eq 1 ]; then
        volt_icon="ðŸ”´"
        volt_status="Unterspannung JETZT!"
    elif [ "$volt_bit16" -ne 0 ]; then
        volt_icon="ðŸŸ¡"
        volt_status="Unterspannung (Vergangenheit)"
    fi
    local signal=$(cat /run/readsb/stats.json 2>/dev/null | jq -r '.last1min.local.peak_signal // -99' 2>/dev/null)
    local sig_int=${signal%.*}

    local sd_errors=$(dmesg | grep -ciE 'mmcblk.*error|mmcblk.*failed|mmc0.*timeout')
    local sd_writes=$(awk '{print int($7 * 512 / 1024 / 1024)}' /sys/block/mmcblk0/stat 2>/dev/null || echo '0')
    local sd_icon="ðŸŸ¢"
    [ "$sd_errors" -gt 0 ] && sd_icon="ðŸ”´"


    # Service-Kategorien (24 Services + zmq-decoder bedingt)
    local CORE_SERVICES="readsb"
    local FEED_SERVICES="piaware fr24feed adsbexchange-feed adsbfi-feed opensky-feeder theairtraffic-feed rbfeeder airplanes-feed pfclient"
    local MLAT_SERVICES="mlathub adsbexchange-mlat adsbfi-mlat airplanes-mlat"
    local WEB_SERVICES="tar1090 graphs1090 adsbexchange-stats"
    local DRONE_SERVICES="dragonsync"
    local OGN_SERVICES="ogn-rf-procserv ogn-decode-procserv ogn2dump1090"
    local ALERT_SERVICES="aircraft-alert-notifier ogn-balloon-notifier drone-alert-notifier"

    # Core
    local core_status="ðŸŸ¢"
    systemctl is-active $CORE_SERVICES &>/dev/null || core_status="ðŸ”´"

    # Upload Feeds
    local feed_ok=0 feed_total=0 feed_fail=""
    for svc in $FEED_SERVICES; do
        ((feed_total++))
        if systemctl is-active "$svc" &>/dev/null; then
            ((feed_ok++))
        else
            feed_fail+=" ${svc%%-*}"
        fi
    done
    local feed_icon="ðŸŸ¢"
    [ "$feed_ok" -lt "$feed_total" ] && feed_icon="ðŸŸ¡"
    [ "$feed_ok" -lt 5 ] && feed_icon="ðŸ”´"

    # MLAT
    local mlat_ok=0 mlat_total=0 mlat_fail=""
    for svc in $MLAT_SERVICES; do
        ((mlat_total++))
        if systemctl is-active "$svc" &>/dev/null; then
            ((mlat_ok++))
        else
            mlat_fail+=" ${svc%%-*}"
        fi
    done
    local mlat_svc_icon="ðŸŸ¢"
    [ "$mlat_ok" -lt "$mlat_total" ] && mlat_svc_icon="ðŸŸ¡"
    [ "$mlat_ok" -lt 2 ] && mlat_svc_icon="ðŸ”´"

    # Web
    local web_ok=0 web_total=0
    for svc in $WEB_SERVICES; do
        ((web_total++))
        systemctl is-active "$svc" &>/dev/null && ((web_ok++))
    done
    local web_icon="ðŸŸ¢"
    [ "$web_ok" -lt "$web_total" ] && web_icon="ðŸŸ¡"

    # DragonSync
    local drone_icon="ðŸŸ¢"
    local drone_count=$(curl -s http://localhost:8088/drones 2>/dev/null | python3 -c "import sys, json; data=json.load(sys.stdin); print(len(data.get('drones', [])))" 2>/dev/null || echo "0")
    local drone_display="DragonSync"
    [ "$drone_count" -gt 0 ] && drone_display="DragonSync - Drohnen: ${drone_count} aktiv"
    systemctl is-active $DRONE_SERVICES &>/dev/null || drone_icon="ðŸŸ¡"

    # OGN
    local ogn_ok=0 ogn_total=0
    for svc in $OGN_SERVICES; do
        ((ogn_total++))
        systemctl is-active "$svc" &>/dev/null && ((ogn_ok++))
    done
    local ogn_icon="ðŸŸ¢"
    [ "$ogn_ok" -lt "$ogn_total" ] && ogn_icon="ðŸŸ¡"
    [ "$ogn_ok" -eq 0 ] && ogn_icon="ðŸ”´"

    # OGN-Statistiken von ogn-decode
    local ogn_stats="?"
    if systemctl is-active ogn-decode-procserv &>/dev/null; then
        local ogn_html=$(curl -s --max-time 2 http://localhost:8081/status.html 2>/dev/null)
        if [ -n "$ogn_html" ]; then
            ogn_stats=$(echo "$ogn_html" | grep -oP 'Aircrafts received over last minute.*?<b>\K[^<]+' | tr -d ' ')
            [ -z "$ogn_stats" ] && ogn_stats="0/0"
        else
            ogn_stats="â³"  # Benchmarking
        fi
    else
        ogn_stats="offline"
    fi
    
    # Alert Services
    local alert_ok=0 alert_total=0
    for svc in $ALERT_SERVICES; do
        ((alert_total++))
        systemctl is-active "$svc" &>/dev/null && ((alert_ok++))
    done
    local alert_icon="ðŸŸ¢"
    [ "$alert_ok" -lt "$alert_total" ] && alert_icon="ðŸŸ¡"
    [ "$alert_ok" -eq 0 ] && alert_icon="ðŸ”´"
    if systemctl is-enabled adsbexchange-mlat &>/dev/null; then
        local mlat_adsbx=$(ss -tn state established 2>/dev/null | grep -qE '(34\.218|54\.244).*(31090|64590)' && echo "OK" || echo "NEIN")
        local mlat_x_icon=$([[ "$mlat_adsbx" == "OK" ]] && echo "ðŸŸ¢" || echo "ðŸ”´")
        mlat_status+="${mlat_x_icon} ADSBx"
    fi
    if systemctl is-enabled adsbfi-mlat &>/dev/null; then
        local mlat_fi=$(ss -tn state established '( dport = :31090 )' 2>/dev/null | grep -q "65\.109" && echo "OK" || echo "NEIN")
        local mlat_fi_icon=$([[ "$mlat_fi" == "OK" ]] && echo "ðŸŸ¢" || echo "ðŸ”´")
        [ -n "$mlat_status" ] && mlat_status+=" | "
        mlat_status+="${mlat_fi_icon} adsb.fi"
    fi
    if pgrep -f "fa-mlat-client" &>/dev/null; then
        [ -n "$mlat_status" ] && mlat_status+=" | "
        mlat_status+="ðŸŸ¢ FA"
    fi
    if systemctl is-enabled airplanes-mlat &>/dev/null; then
        local mlat_air=$(ss -tn state established 2>/dev/null | grep -qE "78\.46\.234\.[0-9]+:31090|65\.109\.[0-9]+\.[0-9]+:31090" && echo "OK" || echo "NEIN")
        local mlat_air_icon=$([[ "$mlat_air" == "OK" ]] && echo "ðŸŸ¢" || echo "ðŸ”´")
        [ -n "$mlat_status" ] && mlat_status+=" | "
        mlat_status+="${mlat_air_icon} airpl"
    fi
    [ -z "$mlat_status" ] && mlat_status="Keine konfiguriert"

    local rtl_icon=$([[ "$rtl" == "OK" ]] && echo "ðŸŸ¢" || echo "ðŸ”´")
    local temp_int=${temp%.*}
    local temp_icon="ðŸŸ¢"
    [ "$temp_int" -ge 55 ] 2>/dev/null && temp_icon="ðŸŸ¡"
    [ "$temp_int" -ge 65 ] 2>/dev/null && temp_icon="ðŸŸ "
    [ "$temp_int" -ge 75 ] 2>/dev/null && temp_icon="ðŸ”´"
    # Signal-QualitÃ¤t: Je nÃ¤her an 0 dB, desto BESSER (in RF-Welt!)
    local sig_icon="ðŸŸ¢"  # Default: GrÃ¼n fÃ¼r gute Signale (-10 bis 0 dB)
    [ "$sig_int" -lt -10 ] 2>/dev/null && sig_icon="ðŸŸ¡"  # -10 bis -20 dB = OK
    [ "$sig_int" -lt -20 ] 2>/dev/null && sig_icon="ðŸ”´"  # < -20 dB = Schwach

    local session_info=""
    if is_maintenance_running; then
        local dur=$(get_maintenance_duration)
        session_info="

*Claude*
ðŸ”§ Wartung lÃ¤uft seit $dur"
    elif [ -f "$DO_LOCK" ] && kill -0 "$(cat "$DO_LOCK" 2>/dev/null)" 2>/dev/null; then
        session_info="

*Claude*
âš¡ /do Befehl lÃ¤uft"
    elif has_open_session; then
        local remaining=$(get_session_remaining)
        session_info="

*Claude*
â³ Frage offen (noch $remaining)"
    fi

    get_firmware_status
    echo "ðŸ“¡ *System Health*

*System*
â± ${uptime_str} | ${cpu_icon} CPU ${cpu_load} | ${ram_icon} RAM ${ram_pct}%

*Hardware*
${rtl_icon} SDR | ${temp_icon} ${temp}Â°C | ${sig_icon} ${signal}dB
${volt_icon} Spannung: ${volt_status}
${fw_icon} Firmware: ${fw_status}

*SD-Karte*
${sd_icon} ${sd_writes}MB seit Boot | Fehler: ${sd_errors}

*Services*
${core_status} Core (readsb)
${feed_icon} Upload Feeds (${feed_ok}/${feed_total})$([ -z "$feed_fail" ] || echo " - Fehlt:$feed_fail")
${mlat_svc_icon} MLAT Services (${mlat_ok}/${mlat_total})$([ -z "$mlat_fail" ] || echo " - Fehlt:$mlat_fail")
${web_icon} Web (${web_ok}/${web_total})
${drone_icon} ${drone_display}
${ogn_icon} OGN/FLARM (${ogn_ok}/${ogn_total}) - Empfang: ${ogn_stats}
${alert_icon} Alerts (${alert_ok}/${alert_total})

*MLAT Sync*
${mlat_status}

${session_info}"
}

#-------------------------------------------------------------------------------
# /stats - Statistiken
#-------------------------------------------------------------------------------
get_stats() {
    local stats=$(cat /run/readsb/stats.json 2>/dev/null)
    local aircraft=$(cat /run/readsb/aircraft.json 2>/dev/null | jq '.aircraft | length' 2>/dev/null || echo "?")
    local msg_rate=$(echo "$stats" | jq -r '.last1min.messages // 0' 2>/dev/null)
    msg_rate=$((msg_rate / 60))
    local tracks_today=$(echo "$stats" | jq -r '.total.tracks.all // 0' 2>/dev/null)
    local positions=$(echo "$stats" | jq -r '.last1min.cpr.global_ok // 0' 2>/dev/null)
    local range_now=$(echo "$stats" | jq -r '.last1min.max_distance // 0' 2>/dev/null)
    local range_max=$(echo "$stats" | jq -r '.total.max_distance // 0' 2>/dev/null)
    range_now=$((range_now / 1852))
    range_max=$((range_max / 1852))

    local mlat_results=""
    if ss -tn state established 2>/dev/null | grep -q "127.0.0.1:30154"; then
        mlat_results+="ðŸŸ¢ ADSBx"
    elif pgrep -f "adsbexchange.*mlat" &>/dev/null; then
        mlat_results+="ðŸŸ¡ ADSBx"
    fi
    if ss -tn state established 2>/dev/null | grep -q "127.0.0.1:30169"; then
        [ -n "$mlat_results" ] && mlat_results+=" | "
        mlat_results+="ðŸŸ¢ adsb.fi"
    elif pgrep -f "adsbfi.*mlat" &>/dev/null; then
        [ -n "$mlat_results" ] && mlat_results+=" | "
        mlat_results+="ðŸŸ¡ adsb.fi"
    fi
    if pgrep -f "fa-mlat-client" &>/dev/null; then
        [ -n "$mlat_results" ] && mlat_results+=" | "
        mlat_results+="ðŸŸ¢ FA"
    fi
    [ -z "$mlat_results" ] && mlat_results="Keine aktiv"

    # OGN Statistiken
    local ogn_last_hour=0
    local ogn_last_min=0
    if systemctl is-active ogn-decode-procserv &>/dev/null; then
        local ogn_html=$(curl -s http://localhost:8081/status.html 2>/dev/null)
        ogn_last_hour=$(echo "$ogn_html" | grep -oP 'Aircrafts received over last hour.*?<b>\s*\K[0-9]+' | head -1)
        ogn_last_min=$(echo "$ogn_html" | grep -oP 'Aircrafts received over last minute.*?<b>\s*\K[0-9]+' | head -1)
        [ -z "$ogn_last_hour" ] && ogn_last_hour=0
        [ -z "$ogn_last_min" ] && ogn_last_min=0
    fi
    local ogn_stats_detailed="ðŸª‚ Empfangen: ${ogn_last_min}/min, ${ogn_last_hour}/Stunde"

    # Drohnen Statistiken
    local drone_current=0
    local drone_total=0
    if systemctl is-active dragonsync &>/dev/null; then
        local drone_data=$(curl -s http://localhost:8088/drones 2>/dev/null)
        drone_current=$(echo "$drone_data" | python3 -c "import sys, json; data=json.load(sys.stdin); print(len(data.get('drones', [])))" 2>/dev/null || echo "0")
        drone_total=$(sudo journalctl -u dragonsync --since "24 hours ago" --no-pager 2>&1 | grep -oP 'mac.*?[0-9a-f:]{17}' | sort -u | wc -l)
    fi
    local drone_stats_detailed="ðŸš Aktuell: ${drone_current} | Letzte 24h: ${drone_total}"

    echo "ðŸ“Š *Statistiken*

*Aktuell*
âœˆï¸ Flugzeuge: ${aircraft}
ðŸ“¨ ${msg_rate} msg/sec
ðŸ“ ${positions} pos/min
ðŸ“¡ Reichweite: ${range_now} nm

*Seit Start*
ðŸ›« Flugzeuge: ${tracks_today}
ðŸ“¡ Max: ${range_max} nm

*MLAT RÃ¼ckkanal*
${mlat_results}

ðŸª‚ *OGN/FLARM Segelflugzeuge*
${ogn_stats_detailed}

ðŸš *Remote ID Drohnen*
${drone_stats_detailed}"

}

#-------------------------------------------------------------------------------
# /log(s) - Letzte Wartung
#-------------------------------------------------------------------------------
get_log() {
    local logfile="/var/log/claude-maintenance/response-$(date +%Y-%m-%d).log"
    local msg=""
    
    if is_maintenance_running; then
        local dur=$(get_maintenance_duration)
        msg="ðŸ”§ *Wartung lÃ¤uft* (${dur})

"
    fi
    
    if [ -f "$logfile" ]; then
        local content=$(tail -30 "$logfile" | tail -c 3500)
        if [ -n "$content" ]; then
            msg="${msg}ðŸ“‹ *Log*
\`\`\`
${content}
\`\`\`"
        else
            msg="${msg}ðŸ“‹ Log ist leer."
        fi
    else
        msg="${msg}ðŸ“‹ Heute noch keine Wartung."
    fi
    
    echo "$msg"
}

#-------------------------------------------------------------------------------
# /wartung - Claude-Wartung starten
#-------------------------------------------------------------------------------
start_maintenance() {
    local instruction="$1"
    local instr_file="/var/lib/claude-pending/user-instruction.txt"
    
    if is_maintenance_running; then
        local dur=$(get_maintenance_duration)
        send_message "âš ï¸ Wartung lÃ¤uft bereits seit $dur. Warte auf Abschluss oder nutze /log fÃ¼r Status."
        return
    fi
    
    if [ -n "$instruction" ]; then
        echo "$instruction" > "$instr_file"
        send_message "ðŸ”§ *Wartung gestartet*
Anweisung: _${instruction}_
â³ Dies kann einige Minuten dauern..."
        log "Wartung mit Anweisung: $instruction"
    else
        rm -f "$instr_file"
        send_message "ðŸ”§ *Wartung gestartet*
â³ Dies kann einige Minuten dauern..."
        log "Wartung manuell gestartet"
    fi
    
    nohup bash -c '
        # HINWEIS: source hier notwendig da Subshell, Config ist root-kontrolliert
        source /etc/telegram-notify.conf
        START_TIME=$(date +%s)
        
        (
            sleep 120
            if [ -f /var/run/claude-respond.lock ]; then
                DUR=$(( ($(date +%s) - START_TIME) / 60 ))
                curl -s --max-time 10 -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                    -d chat_id="${TELEGRAM_CHAT_ID}" \
                    -d text="â³ Wartung lÃ¤uft seit ${DUR} min... (arbeitet noch)" \
                    -d parse_mode="Markdown" > /dev/null 2>&1
            fi
        ) &
        WATCHER_PID=$!
        
        /usr/local/sbin/claude-respond-to-reports
        EXIT=$?
        
        kill $WATCHER_PID 2>/dev/null
        
        END_TIME=$(date +%s)
        DURATION=$(( (END_TIME - START_TIME) / 60 ))
        
        if [ $EXIT -eq 0 ]; then
            curl -s --max-time 10 -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                -d chat_id="${TELEGRAM_CHAT_ID}" \
                -d text="âœ… *Wartung abgeschlossen* (${DURATION} min)
/log fÃ¼r Details" \
                -d parse_mode="Markdown" > /dev/null
        else
            curl -s --max-time 10 -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                -d chat_id="${TELEGRAM_CHAT_ID}" \
                -d text="âš ï¸ *Wartung fehlgeschlagen* (Exit: $EXIT, ${DURATION} min)
/log fÃ¼r Fehlerdetails" \
                -d parse_mode="Markdown" > /dev/null
        fi
    ' &>/dev/null &
}

#-------------------------------------------------------------------------------
# Befehlsverarbeitung
#-------------------------------------------------------------------------------
handle_command() {
    local text="$1"
    text=$(sanitize_input "$text")
    
    local cmd=$(echo "$text" | awk '{print $1}' | tr '[:upper:]' '[:lower:]')
    local args=$(echo "$text" | cut -d' ' -f2- -s)


    # Command-Lock fÃ¼r langsame Befehle (verbessert)
    if [[ "$cmd" =~ ^/(status|stats|log|wartung)$ ]]; then
        local cmd_name="${cmd#/}"  # Entfernt fÃ¼hrenden /
        local lock_file="$COMMAND_LOCK.$cmd_name"
        if [ -f "$lock_file" ]; then
            local lock_age=$(($(date +%s) - $(stat -c %Y "$lock_file" 2>/dev/null || echo 0)))
            if [ "$lock_age" -lt 3 ]; then
                log "Ignoriere Doppel-Request: $cmd (Lock aktiv)"
                return  # Ignoriere Doppel-Request innerhalb 3 Sekunden
            fi
        fi
        touch "$lock_file"
        trap 'rm -f "''"' RETURN
    fi

    case "$cmd" in
        /start|/help|/hilfe)
            local help_text="ðŸ¤– *ADS-B Feeder Bot*

/status - System Health
/stats - Statistiken (ADS-B, OGN, Drohnen)
/log - Wartungs-Log

*Claude-Befehle:*
/do <anweisung> - Schnelle Anweisung
/wartung [text] - Volle Wartung"
            if has_open_session; then
                help_text+="

*Session offen:*
/abbrechen - Session abbrechen
_Oder einfach antworten_"
            fi
            send_message "$help_text"
            return
            ;;
        /status)
            send_message "$(get_status)"
            return
            ;;
        /stats)
            send_message "$(get_stats)"
            return
            ;;
        /log|/logs)
            send_message "$(get_log)"
            return
            ;;
        /do)
            handle_do "$args"
            return
            ;;
        /wartung|/maintenance)
            start_maintenance "$args"
            return
            ;;
        /abbrechen|/cancel)
            handle_abbrechen
            return
            ;;
        /*)
            send_message "â“ Unbekannt. /help"
            return
            ;;
    esac

    if has_open_session; then
        echo "$text" > "$ANSWER_FILE"
        send_message "âœ… Antwort erhalten, wird validiert..."
        log "Antwort auf offene Session: $text"
    else
        send_message "ðŸ’¬ Keine Frage offen. /help"
    fi
}

#-------------------------------------------------------------------------------
# Hauptschleife
#-------------------------------------------------------------------------------
mkdir -p /var/run
[ -f "$LAST_UPDATE_FILE" ] || echo "0" > "$LAST_UPDATE_FILE"
# Ã–ffne Lock-FD global (hÃ¤lt Lock bis Prozess-Ende)
exec 200>/var/run/telegram-bot.lock
acquire_bot_lock
log "Bot-Daemon gestartet"

while true; do
    LAST_UPDATE=$(cat "$LAST_UPDATE_FILE")
    RESPONSE=$(curl -s --max-time 35 "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/getUpdates?offset=$((LAST_UPDATE + 1))&timeout=30" 2>/dev/null)

    if [ $? -ne 0 ] || ! echo "$RESPONSE" | jq -e '.ok' > /dev/null 2>&1; then
        sleep 10
        continue
    fi


    # Array-basierte Update-Verarbeitung (nicht in Subshell)
    mapfile -t updates < <(echo "$RESPONSE" | jq -c '.result[]' 2>/dev/null)
    for update in "${updates[@]}"; do
        UPDATE_ID=$(echo "$update" | jq -r '.update_id')
        CHAT_ID=$(echo "$update" | jq -r '.message.chat.id // empty')
        TEXT=$(echo "$update" | jq -r '.message.text // empty')

        echo "$UPDATE_ID" > "$LAST_UPDATE_FILE"

        if [ "$CHAT_ID" = "$TELEGRAM_CHAT_ID" ] && [ -n "$TEXT" ]; then
            log "Empfangen: $TEXT"
            handle_command "$TEXT"
        fi
    done
done
